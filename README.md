![1](https://github.com/user-attachments/assets/e871f92f-750f-4c67-a67f-f7a7fd400629)

![2](https://github.com/user-attachments/assets/50252ccc-a0c5-4de2-8585-deb60630dddc)  ![3](https://github.com/user-attachments/assets/268493a9-4193-48ae-a45f-2d9b93c70266)
![4](https://github.com/user-attachments/assets/52bf96ae-4846-4978-aa6f-85237ff5d36b)







## üß† Introdu√ß√£o

### Por que aprender Estrutura de Dados?

Se voc√™ quer aprender a programar de verdade, precisa ir al√©m de "fazer funcionar". Precisa entender *como* o seu programa funciona por dentro. Estruturas de dados s√£o o cora√ß√£o disso. Elas definem como as informa√ß√µes s√£o armazenadas, acessadas e manipuladas.

Imagine que voc√™ vai mudar de casa. N√£o basta jogar tudo no caminh√£o de qualquer jeito. √â preciso organizar: roupas em malas, pratos em caixas acolchoadas, documentos em pastas. Em programa√ß√£o √© igual. Estruturas de dados te ajudam a organizar a bagun√ßa e tornar tudo mais r√°pido, eficiente e limpo.

Ao dominar estruturas de dados, voc√™ vai:

* Resolver problemas com mais eleg√¢ncia
* Escrever c√≥digo mais r√°pido e eficiente
* Entender melhor os algoritmos
* Estar preparado para entrevistas de emprego em tecnologia

### Como usar este eBook

Este eBook foi criado com um objetivo: **te ensinar estrutura de dados de forma simples, direta e sem enrola√ß√£o**.

Formato:

* Cap√≠tulos curtos e objetivos
* Linguagem informal e com analogias do cotidiano
* Exemplos pr√°ticos e comentados
* Desafios simples para exercitar

Siga a ordem dos cap√≠tulos, reflita sobre os exemplos, e tente imaginar situa√ß√µes do seu dia a dia onde aquilo faria sentido. A cada t√≥pico, pense: *"Onde eu j√° vi isso acontecer na vida real?"*

Vamos nessa?

---

## üß© Parte 1 ‚Äî Fundamentos Essenciais

### O que s√£o Estruturas de Dados, afinal?

Estruturas de dados s√£o formas de **organizar, armazenar e acessar informa√ß√µes** de maneira eficiente dentro de um programa.

Na pr√°tica, √© como organizar a vida:

* Uma **playlist** √© uma lista de m√∫sicas (Array)
* Sua **lista de tarefas** tem ordem de prioridade (Fila ou Pilha)
* Um **arm√°rio** tem compartimentos para cada tipo de objeto (Hash Table)

Ou seja, cada tipo de estrutura tem um formato diferente que serve para resolver um tipo de problema.

### Pensando como um programador

Um programador pensa em **como representar um problema com estruturas e l√≥gica**. Antes de codar, ele imagina:

* Que tipo de dado vou usar?
* Com que frequ√™ncia vou acessar ou modificar esse dado?
* Preciso de ordem? R√°pida busca? Evitar repetidos?

Por exemplo: para armazenar os nomes dos clientes em uma loja virtual, voc√™ pode usar uma lista. Mas se quiser buscar rapidamente um cliente pelo e-mail, talvez um dicion√°rio seja melhor.

### Mem√≥ria e performance: como o computador pensa

Seu computador √© r√°pido, mas **n√£o √© m√°gico**. Cada vez que voc√™ acessa, busca ou muda um dado, ele faz opera√ß√µes na mem√≥ria. Algumas estruturas facilitam isso, outras dificultam.

Pense assim: voc√™ vai viajar. Pode colocar tudo em uma mala desorganizada (lento pra encontrar) ou em v√°rias necessaires separadas (r√°pido e organizado). A segunda op√ß√£o √© melhor. √â isso que uma boa estrutura de dados faz.

A escolha da estrutura **afeta diretamente o desempenho do seu programa**.

---

## üì¶ Parte 2 ‚Äî Estruturas Lineares no Dia a Dia

### Arrays e Listas: o arm√°rio de sapatos da programa√ß√£o

Arrays s√£o como arm√°rios com divis√≥rias fixas. Cada item tem um lugar espec√≠fico, e voc√™ acessa pelo n√∫mero da porta (o √≠ndice).

Exemplo: `array[0]` √© o primeiro item, `array[1]` o segundo e assim por diante. R√°pido para acessar, mas dif√≠cil de crescer ou encolher.

Listas (ou listas din√¢micas) s√£o mais flex√≠veis ‚Äî como uma sapateira extens√≠vel. Voc√™ pode adicionar ou remover sapatos facilmente, mas leva mais tempo para encontrar um espec√≠fico.

**Use Arrays quando:**

* Voc√™ sabe exatamente quantos elementos ter√°.
* Precisa de acesso r√°pido por √≠ndice.

**Use Listas quando:**

* A quantidade de elementos muda bastante.
* Vai adicionar/remover itens com frequ√™ncia.

---

### Pilhas (Stacks): pratos empilhados em um restaurante

Imagine uma pilha de pratos limpos. Voc√™ sempre coloca o novo prato em cima (push) e pega o √∫ltimo colocado (pop). Isso √© o conceito de **LIFO (Last In, First Out)**.

Usamos pilhas para:

* Desfazer a√ß√µes (Ctrl+Z)
* Controlar chamadas de fun√ß√µes
* Voltar p√°ginas no navegador

**Fun√ß√µes principais:**

* `push(item)`: adiciona um item ao topo
* `pop()`: remove o item do topo
* `peek()`: olha o topo sem remover

---

### Filas (Queues): a fila do banco, sem jeitinho brasileiro

A fila √© justa: quem chega primeiro, sai primeiro. Isso √© **FIFO (First In, First Out)**.

Voc√™ adiciona no fim da fila (`enqueue`) e remove do in√≠cio (`dequeue`).

Usamos filas para:

* Processar tarefas em ordem
* Atender requisi√ß√µes em sistemas
* Controlar impress√£o de documentos

**Fun√ß√µes principais:**

* `enqueue(item)`: adiciona no fim da fila
* `dequeue()`: remove o primeiro
* `peek()`: olha o primeiro sem remover

---

### Listas Ligadas: vag√µes de trem conectados

Diferente dos arrays, onde tudo est√° lado a lado na mem√≥ria, nas **listas ligadas** cada elemento aponta para o pr√≥ximo.

Imagine uma sequ√™ncia de vag√µes onde cada um tem um acoplamento pro pr√≥ximo.

**Vantagens:**

* Cresce facilmente
* Remo√ß√£o e inser√ß√£o mais eficientes em posi√ß√µes intermedi√°rias

**Desvantagens:**

* Mais dif√≠cil de percorrer rapidamente
* Gasta mais mem√≥ria (por causa dos ponteiros)

**Tipos:**

* Lista simplesmente ligada
* Lista duplamente ligada
* Lista circular

---

## üß≠ Parte 3 ‚Äî Organizando e Localizando com Intelig√™ncia

### Dicion√°rios e Hash Tables: o mapa de contatos do seu celular

Imagine procurar um contato no celular: voc√™ digita o nome e j√° encontra o n√∫mero. Isso √© uma opera√ß√£o com **chave-valor** ‚Äî e √© exatamente como funcionam os dicion√°rios.

Em programa√ß√£o, dicion√°rios (ou mapas/hash tables) armazenam dados usando uma **chave √∫nica** para acessar rapidamente um valor associado.

Exemplo:

```python
dicionario = {"lucas": "9999-1234", "ana": "9888-0000"}
print(dicionario["ana"])  # sa√≠da: 9888-0000
```

**Vantagens:**

* Busca muito r√°pida
* Ideal para consultas por identificadores √∫nicos

**Desvantagens:**

* Consome mais mem√≥ria
* N√£o tem ordem garantida (em alguns casos)

---

### Conjuntos (Sets): o que voc√™ j√° tem na cole√ß√£o

Sets s√£o como cole√ß√µes que **n√£o aceitam itens duplicados**. Imagine colecionar figurinhas e garantir que nenhuma repetida v√° para o √°lbum.

Muito usado quando precisamos:

* Remover duplicatas
* Fazer opera√ß√µes de compara√ß√£o entre grupos (uni√£o, interse√ß√£o, diferen√ßa)

Exemplo:

```python
conjunto = {"banana", "ma√ß√£", "banana"}
print(conjunto)  # sa√≠da: {"banana", "ma√ß√£"}
```

---

## üå≥ Parte 4 ‚Äî Estruturas N√£o Lineares

### √Årvores (Trees): sua √°rvore geneal√≥gica ou decis√µes do dia a dia

√Årvores s√£o estruturas em formato hier√°rquico. Pense em uma √°rvore geneal√≥gica ou em um menu de decis√µes.

Cada **n√≥** pode ter v√°rios **filhos**, mas apenas **um pai** (exceto a raiz).

Usos comuns:

* Representar hierarquias (como categorias em sites)
* √Årvores de decis√£o (ex: jogos)
* Estruturas de busca (como a Binary Search Tree ‚Äî BST)

---

### Grafos (Graphs): como o Google Maps conecta os caminhos

Grafos s√£o conjuntos de **n√≥s** (ou v√©rtices) conectados por **arestas**. Eles representam relacionamentos complexos, como:

* Mapa de ruas
* Redes sociais
* Liga√ß√µes entre aeroportos

Existem grafos direcionados (com sentido) e n√£o direcionados (conex√µes livres). E ainda, podem ser ponderados (com custo) ou n√£o.

---

## üéÆ Parte 5 ‚Äî Aplica√ß√µes Pr√°ticas e Pr√≥ximos Passos

### Qual estrutura usar?

| Situa√ß√£o                          | Estrutura recomendada |
| --------------------------------- | --------------------- |
| Lista de tarefas                  | Lista, Pilha ou Fila  |
| Agenda de contatos                | Dicion√°rio            |
| Controle de hist√≥rico (navegador) | Pilha                 |
| Fila de impress√£o                 | Fila                  |
| Sistema de categorias             | √Årvore                |
| Rotas de mapa                     | Grafo                 |

---

### Mini projetos para treinar o que aprendeu

* **Simulador de fila de supermercado** (com `Queue`)
* **Agenda de contatos com busca por nome** (com `Dict`)
* **Navegador com bot√£o ‚Äúdesfazer/refazer‚Äù** (com `Stack`)
* **Organizador de tarefas com prioridades** (com √°rvore ou heap)

---

### Erros comuns que iniciantes cometem com estruturas de dados

* Escolher a estrutura errada para o problema
* Tentar reinventar estruturas j√° prontas
* Usar listas para tudo (mesmo quando ineficiente)
* N√£o considerar a performance

---

### Pr√≥ximos passos: como continuar evoluindo

* Estude algoritmos cl√°ssicos
* Participe de desafios de programa√ß√£o (Ex: HackerRank, LeetCode)
* Leia c√≥digos open source
* Pratique resolvendo problemas reais

---

## Exemplos Praticos - Codigo Python

---

## üß© Parte 1 ‚Äî Fundamentos Essenciais

### O que s√£o Estruturas de Dados, afinal?

Estruturas de dados s√£o formas de **organizar, armazenar e acessar informa√ß√µes** de maneira eficiente dentro de um programa.

Na pr√°tica, √© como organizar a vida:

* Uma **playlist** √© uma lista de m√∫sicas (Array)
* Sua **lista de tarefas** tem ordem de prioridade (Fila ou Pilha)
* Um **arm√°rio** tem compartimentos para cada tipo de objeto (Hash Table)

Ou seja, cada tipo de estrutura tem um formato diferente que serve para resolver um tipo de problema.

---

## üì¶ Parte 2 ‚Äî Estruturas Lineares no Dia a Dia

### Arrays e Listas

```python
# Exemplo de Array (lista em Python)
nomes = ["Ana", "Bruno", "Carlos"]
print(nomes[0])  # Ana
nomes.append("Daniel")
print(nomes)
```

### Pilhas (Stacks)

```python
# Exemplo de Pilha usando lista
pilha = []
pilha.append("prato1")
pilha.append("prato2")
pilha.append("prato3")
print(pilha.pop())  # prato3
print(pilha)        # ['prato1', 'prato2']
```

### Filas (Queues)

```python
# Exemplo de Fila com deque
from collections import deque
fila = deque()
fila.append("cliente1")
fila.append("cliente2")
print(fila.popleft())  # cliente1
print(fila)            # deque(['cliente2'])
```

### Listas Ligadas

```python
# Exemplo b√°sico de Lista Ligada
class No:
    def __init__(self, dado):
        self.dado = dado
        self.proximo = None

no1 = No("A")
no2 = No("B")
no3 = No("C")
no1.proximo = no2
no2.proximo = no3

# Percorrer lista
atual = no1
while atual:
    print(atual.dado)
    atual = atual.proximo
```

---

## üß≠ Parte 3 ‚Äî Organizando e Localizando com Intelig√™ncia

### Dicion√°rios (Hash Tables)

```python
# Exemplo de Dicion√°rio
contatos = {"Lucas": "9999-1234", "Ana": "9888-0000"}
print(contatos["Ana"])
contatos["Jo√£o"] = "9777-3333"
print(contatos)
```

### Conjuntos (Sets)

```python
# Exemplo de Set
frutas = {"ma√ß√£", "banana", "ma√ß√£"}
print(frutas)  # {'ma√ß√£', 'banana'}
frutas.add("laranja")
print(frutas)
```

---

## üå≥ Parte 4 ‚Äî Estruturas N√£o Lineares

### √Årvores (√°rvore bin√°ria simples)

```python
class No:
    def __init__(self, valor):
        self.valor = valor
        self.esq = None
        self.dir = None

raiz = No(10)
raiz.esq = No(5)
raiz.dir = No(15)

# Percurso em ordem
def em_ordem(no):
    if no:
        em_ordem(no.esq)
        print(no.valor)
        em_ordem(no.dir)

em_ordem(raiz)
```

### Grafos (representa√ß√£o com dicion√°rio)

```python
# Grafo simples n√£o direcionado
grafo = {
    "A": ["B", "C"],
    "B": ["A", "D"],
    "C": ["A", "D"],
    "D": ["B", "C"]
}

# Percorrer vizinhos de A
print("Vizinhos de A:", grafo["A"])
```

---

## üéÆ Parte 5 ‚Äî Aplica√ß√µes Pr√°ticas e Mini Projetos

```python
# Simulador de fila de supermercado
from collections import deque
fila = deque()
fila.append("Cliente 1")
fila.append("Cliente 2")
print("Atendendo:", fila.popleft())

# Agenda com busca
agenda = {"Lucas": "1111-2222", "Maria": "3333-4444"}
nome = "Maria"
if nome in agenda:
    print("N√∫mero:", agenda[nome])

# Navegador com bot√£o de desfazer
historico = []
historico.append("P√°gina 1")
historico.append("P√°gina 2")
print("Desfazer:", historico.pop())

# Organizador de tarefas com √°rvore (representa√ß√£o simples)
tarefas = {
    "Trabalho": ["Relat√≥rio", "Apresenta√ß√£o"],
    "Casa": ["Lavar roupa", "Limpar"]
}
print("Tarefas do Trabalho:", tarefas["Trabalho"])
```
---

Obrigado por ler! üöÄ

**Autor: Lucas Lima**
